'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('pixijs/core');
var canUseNewCanvasBlendModes = require('./utils/canUseNewCanvasBlendModes.js');

const canvasUtils = {
  canvas: null,
  getTintedCanvas: (sprite, color) => {
    const texture = sprite.texture;
    color = canvasUtils.roundColor(color);
    const stringColor = `#${`00000${(color | 0).toString(16)}`.slice(-6)}`;
    texture.tintCache = texture.tintCache || {};
    const cachedCanvas = texture.tintCache[stringColor];
    let canvas;
    if (cachedCanvas) {
      if (cachedCanvas.tintId === texture._updateID) {
        return texture.tintCache[stringColor];
      }
      canvas = texture.tintCache[stringColor];
    } else {
      canvas = core.settings.ADAPTER.createCanvas();
    }
    canvasUtils.tintMethod(texture, color, canvas);
    canvas.tintId = texture._updateID;
    if (canvasUtils.convertTintToImage && canvas.toDataURL !== void 0) {
      const tintImage = new Image();
      tintImage.src = canvas.toDataURL();
      texture.tintCache[stringColor] = tintImage;
    } else {
      texture.tintCache[stringColor] = canvas;
    }
    return canvas;
  },
  getTintedPattern: (texture, color) => {
    color = canvasUtils.roundColor(color);
    const stringColor = `#${`00000${(color | 0).toString(16)}`.slice(-6)}`;
    texture.patternCache = texture.patternCache || {};
    let pattern = texture.patternCache[stringColor];
    if (pattern?.tintId === texture._updateID) {
      return pattern;
    }
    if (!canvasUtils.canvas) {
      canvasUtils.canvas = core.settings.ADAPTER.createCanvas();
    }
    canvasUtils.tintMethod(texture, color, canvasUtils.canvas);
    pattern = canvasUtils.canvas.getContext("2d").createPattern(canvasUtils.canvas, "repeat");
    pattern.tintId = texture._updateID;
    texture.patternCache[stringColor] = pattern;
    return pattern;
  },
  tintWithMultiply: (texture, color, canvas) => {
    const context = canvas.getContext("2d");
    const crop = texture._frame.clone();
    const resolution = texture.baseTexture.resolution;
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;
    canvas.width = Math.ceil(crop.width);
    canvas.height = Math.ceil(crop.height);
    context.save();
    context.fillStyle = `#${`00000${(color | 0).toString(16)}`.slice(-6)}`;
    context.fillRect(0, 0, crop.width, crop.height);
    context.globalCompositeOperation = "multiply";
    const source = texture.baseTexture.getDrawableSource();
    context.drawImage(source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
    context.globalCompositeOperation = "destination-atop";
    context.drawImage(source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
    context.restore();
  },
  tintWithOverlay: (texture, color, canvas) => {
    const context = canvas.getContext("2d");
    const crop = texture._frame.clone();
    const resolution = texture.baseTexture.resolution;
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;
    canvas.width = Math.ceil(crop.width);
    canvas.height = Math.ceil(crop.height);
    context.save();
    context.globalCompositeOperation = "copy";
    context.fillStyle = `#${`00000${(color | 0).toString(16)}`.slice(-6)}`;
    context.fillRect(0, 0, crop.width, crop.height);
    context.globalCompositeOperation = "destination-atop";
    context.drawImage(texture.baseTexture.getDrawableSource(), crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
    context.restore();
  },
  tintWithPerPixel: (texture, color, canvas) => {
    const context = canvas.getContext("2d");
    const crop = texture._frame.clone();
    const resolution = texture.baseTexture.resolution;
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;
    canvas.width = Math.ceil(crop.width);
    canvas.height = Math.ceil(crop.height);
    context.save();
    context.globalCompositeOperation = "copy";
    context.drawImage(texture.baseTexture.getDrawableSource(), crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
    context.restore();
    const rgbValues = core.utils.hex2rgb(color);
    const r = rgbValues[0];
    const g = rgbValues[1];
    const b = rgbValues[2];
    const pixelData = context.getImageData(0, 0, crop.width, crop.height);
    const pixels = pixelData.data;
    for (let i = 0; i < pixels.length; i += 4) {
      pixels[i + 0] *= r;
      pixels[i + 1] *= g;
      pixels[i + 2] *= b;
    }
    context.putImageData(pixelData, 0, 0);
  },
  roundColor: (color) => {
    const step = canvasUtils.cacheStepsPerColorChannel;
    const rgbValues = core.utils.hex2rgb(color);
    rgbValues[0] = Math.min(255, rgbValues[0] / step * step);
    rgbValues[1] = Math.min(255, rgbValues[1] / step * step);
    rgbValues[2] = Math.min(255, rgbValues[2] / step * step);
    return core.utils.rgb2hex(rgbValues);
  },
  cacheStepsPerColorChannel: 8,
  convertTintToImage: false,
  canUseMultiply: canUseNewCanvasBlendModes.canUseNewCanvasBlendModes(),
  tintMethod: null
};
canvasUtils.tintMethod = canvasUtils.canUseMultiply ? canvasUtils.tintWithMultiply : canvasUtils.tintWithPerPixel;

exports.canvasUtils = canvasUtils;
//# sourceMappingURL=canvasUtils.js.map

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('pixijs/core');

class CanvasObjectRendererSystem {
  constructor(renderer) {
    this.renderer = renderer;
  }
  render(displayObject, options) {
    const renderer = this.renderer;
    if (!renderer.view) {
      return;
    }
    const _context = renderer.canvasContext;
    let renderTexture;
    let clear;
    let transform;
    let skipUpdateTransform;
    if (options) {
      renderTexture = options.renderTexture;
      clear = options.clear;
      transform = options.transform;
      skipUpdateTransform = options.skipUpdateTransform;
    }
    this.renderingToScreen = !renderTexture;
    renderer.emit("prerender");
    const rootResolution = renderer.resolution;
    if (renderTexture) {
      renderTexture = renderTexture.castToBaseTexture();
      if (!renderTexture._canvasRenderTarget) {
        renderTexture._canvasRenderTarget = new core.utils.CanvasRenderTarget(renderTexture.width, renderTexture.height, renderTexture.resolution);
        renderTexture.resource = new core.CanvasResource(renderTexture._canvasRenderTarget.canvas);
        renderTexture.valid = true;
      }
      _context.activeContext = renderTexture._canvasRenderTarget.context;
      renderer.canvasContext.activeResolution = renderTexture._canvasRenderTarget.resolution;
    } else {
      _context.activeContext = _context.rootContext;
      _context.activeResolution = rootResolution;
    }
    const context2D = _context.activeContext;
    _context._projTransform = transform || null;
    if (!renderTexture) {
      this.lastObjectRendered = displayObject;
    }
    if (!skipUpdateTransform) {
      const cacheParent = displayObject.enableTempParent();
      displayObject.updateTransform();
      displayObject.disableTempParent(cacheParent);
    }
    context2D.save();
    context2D.setTransform(1, 0, 0, 1, 0, 0);
    context2D.globalAlpha = 1;
    _context._activeBlendMode = core.BLEND_MODES.NORMAL;
    _context._outerBlend = false;
    context2D.globalCompositeOperation = _context.blendModes[core.BLEND_MODES.NORMAL];
    if (clear ?? renderer.background.clearBeforeRender) {
      if (this.renderingToScreen) {
        context2D.clearRect(0, 0, renderer.width, renderer.height);
        const background = renderer.background;
        if (background.alpha > 0) {
          context2D.globalAlpha = background.alpha;
          context2D.fillStyle = background.colorString;
          context2D.fillRect(0, 0, renderer.width, renderer.height);
          context2D.globalAlpha = 1;
        }
      } else {
        renderTexture = renderTexture;
        renderTexture._canvasRenderTarget.clear();
        const clearColor = renderTexture.clearColor;
        if (clearColor[3] > 0) {
          context2D.globalAlpha = clearColor[3] ?? 1;
          context2D.fillStyle = core.utils.hex2string(core.utils.rgb2hex(clearColor));
          context2D.fillRect(0, 0, renderTexture.realWidth, renderTexture.realHeight);
          context2D.globalAlpha = 1;
        }
      }
    }
    const tempContext = _context.activeContext;
    _context.activeContext = context2D;
    displayObject.renderCanvas(renderer);
    _context.activeContext = tempContext;
    context2D.restore();
    _context.activeResolution = rootResolution;
    _context._projTransform = null;
    renderer.emit("postrender");
  }
  destroy() {
    this.lastObjectRendered = null;
    this.render = null;
  }
}
CanvasObjectRendererSystem.extension = {
  type: core.ExtensionType.CanvasRendererSystem,
  name: "objectRenderer"
};
core.extensions.add(CanvasObjectRendererSystem);

exports.CanvasObjectRendererSystem = CanvasObjectRendererSystem;
//# sourceMappingURL=CanvasObjectRendererSystem.js.map

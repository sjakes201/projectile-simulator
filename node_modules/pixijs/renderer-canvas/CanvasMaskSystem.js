'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('pixijs/core');

class CanvasMaskSystem {
  constructor(renderer) {
    this._foundShapes = [];
    this.renderer = renderer;
  }
  pushMask(maskData) {
    const renderer = this.renderer;
    const maskObject = maskData.maskObject || maskData;
    renderer.canvasContext.activeContext.save();
    const foundShapes = this._foundShapes;
    this.recursiveFindShapes(maskObject, foundShapes);
    if (foundShapes.length > 0) {
      const context = renderer.canvasContext.activeContext;
      context.beginPath();
      for (let i = 0; i < foundShapes.length; i++) {
        const shape = foundShapes[i];
        const transform = shape.transform.worldTransform;
        this.renderer.canvasContext.setContextTransform(transform);
        this.renderGraphicsShape(shape);
      }
      foundShapes.length = 0;
      context.clip();
    }
  }
  recursiveFindShapes(container, out) {
    if (container.geometry && container.geometry.graphicsData) {
      out.push(container);
    }
    const { children } = container;
    if (children) {
      for (let i = 0; i < children.length; i++) {
        this.recursiveFindShapes(children[i], out);
      }
    }
  }
  renderGraphicsShape(graphics) {
    graphics.finishPoly();
    const context = this.renderer.canvasContext.activeContext;
    const graphicsData = graphics.geometry.graphicsData;
    const len = graphicsData.length;
    if (len === 0) {
      return;
    }
    for (let i = 0; i < len; i++) {
      const data = graphicsData[i];
      const shape = data.shape;
      if (shape.type === core.SHAPES.POLY) {
        let points = shape.points;
        const holes = data.holes;
        let outerArea;
        let innerArea;
        let px;
        let py;
        context.moveTo(points[0], points[1]);
        for (let j = 1; j < points.length / 2; j++) {
          context.lineTo(points[j * 2], points[j * 2 + 1]);
        }
        if (holes.length > 0) {
          outerArea = 0;
          px = points[0];
          py = points[1];
          for (let j = 2; j + 2 < points.length; j += 2) {
            outerArea += (points[j] - px) * (points[j + 3] - py) - (points[j + 2] - px) * (points[j + 1] - py);
          }
          for (let k = 0; k < holes.length; k++) {
            points = holes[k].shape.points;
            if (!points) {
              continue;
            }
            innerArea = 0;
            px = points[0];
            py = points[1];
            for (let j = 2; j + 2 < points.length; j += 2) {
              innerArea += (points[j] - px) * (points[j + 3] - py) - (points[j + 2] - px) * (points[j + 1] - py);
            }
            if (innerArea * outerArea < 0) {
              context.moveTo(points[0], points[1]);
              for (let j = 2; j < points.length; j += 2) {
                context.lineTo(points[j], points[j + 1]);
              }
            } else {
              context.moveTo(points[points.length - 2], points[points.length - 1]);
              for (let j = points.length - 4; j >= 0; j -= 2) {
                context.lineTo(points[j], points[j + 1]);
              }
            }
            if (holes[k].shape.closeStroke) {
              context.closePath();
            }
          }
        }
        if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
          context.closePath();
        }
      } else if (shape.type === core.SHAPES.RECT) {
        context.rect(shape.x, shape.y, shape.width, shape.height);
        context.closePath();
      } else if (shape.type === core.SHAPES.CIRC) {
        context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
        context.closePath();
      } else if (shape.type === core.SHAPES.ELIP) {
        const w = shape.width * 2;
        const h = shape.height * 2;
        const x = shape.x - w / 2;
        const y = shape.y - h / 2;
        const kappa = 0.5522848;
        const ox = w / 2 * kappa;
        const oy = h / 2 * kappa;
        const xe = x + w;
        const ye = y + h;
        const xm = x + w / 2;
        const ym = y + h / 2;
        context.moveTo(x, ym);
        context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
        context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
        context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
        context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
        context.closePath();
      } else if (shape.type === core.SHAPES.RREC) {
        const rx = shape.x;
        const ry = shape.y;
        const width = shape.width;
        const height = shape.height;
        let radius = shape.radius;
        const maxRadius = Math.min(width, height) / 2;
        radius = radius > maxRadius ? maxRadius : radius;
        context.moveTo(rx, ry + radius);
        context.lineTo(rx, ry + height - radius);
        context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
        context.lineTo(rx + width - radius, ry + height);
        context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
        context.lineTo(rx + width, ry + radius);
        context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
        context.lineTo(rx + radius, ry);
        context.quadraticCurveTo(rx, ry, rx, ry + radius);
        context.closePath();
      }
    }
  }
  popMask(renderer) {
    renderer.canvasContext.activeContext.restore();
    renderer.canvasContext.invalidateBlendMode();
  }
  destroy() {
  }
}
CanvasMaskSystem.extension = {
  type: core.ExtensionType.CanvasRendererSystem,
  name: "mask"
};
core.extensions.add(CanvasMaskSystem);

exports.CanvasMaskSystem = CanvasMaskSystem;
//# sourceMappingURL=CanvasMaskSystem.js.map

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var assets = require('pixijs/assets');
var compressedTextures = require('pixijs/compressed-textures');
var core = require('pixijs/core');
var Basis = require('../Basis.js');
var TranscoderWorker = require('../TranscoderWorker.js');
var BasisParser = require('./BasisParser.js');

const loadBasis = {
  extension: {
    type: core.ExtensionType.LoadParser,
    priority: assets.LoaderParserPriority.High
  },
  test(url) {
    return assets.checkExtension(url, ".basis");
  },
  async load(url, asset, loader) {
    await TranscoderWorker.TranscoderWorker.onTranscoderInitialized;
    const response = await core.settings.ADAPTER.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    const resources = await BasisParser.BasisParser.transcode(arrayBuffer);
    const type = Basis.BASIS_FORMAT_TO_TYPE[resources.basisFormat];
    const format = resources.basisFormat !== Basis.BASIS_FORMATS.cTFRGBA32 ? core.FORMATS.RGB : core.FORMATS.RGBA;
    const textures = resources.map((resource) => {
      const base = new core.BaseTexture(resource, {
        mipmap: resource instanceof compressedTextures.CompressedTextureResource && resource.levels > 1 ? core.MIPMAP_MODES.ON_MANUAL : core.MIPMAP_MODES.OFF,
        alphaMode: core.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
        type,
        format,
        ...asset.data
      });
      return assets.createTexture(base, loader, url);
    });
    return textures.length === 1 ? textures[0] : textures;
  },
  unload(texture) {
    if (Array.isArray(texture)) {
      texture.forEach((t) => t.destroy(true));
    } else {
      texture.destroy(true);
    }
  }
};
core.extensions.add(loadBasis);

exports.loadBasis = loadBasis;
//# sourceMappingURL=loadBasis.js.map

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var TranscoderWorkerWrapper = require('./TranscoderWorkerWrapper.js');

const _TranscoderWorker = class {
  constructor() {
    this.requests = {};
    this.onMessage = (e) => {
      const data = e.data;
      if (data.type === "init") {
        if (!data.success) {
          throw new Error("BasisResource.TranscoderWorker failed to initialize.");
        }
        this.isInit = true;
        this.onInit();
      } else if (data.type === "transcode") {
        --this.load;
        const requestID = data.requestID;
        if (data.success) {
          this.requests[requestID].resolve(data);
        } else {
          this.requests[requestID].reject();
        }
        delete this.requests[requestID];
      }
    };
    this.isInit = false;
    this.load = 0;
    this.initPromise = new Promise((resolve) => {
      this.onInit = resolve;
    });
    if (!_TranscoderWorker.wasmSource) {
      console.warn("resources.BasisResource.TranscoderWorker has not been given the transcoder WASM binary!");
    }
    this.worker = new Worker(_TranscoderWorker.workerURL);
    this.worker.onmessage = this.onMessage;
    this.worker.postMessage({
      type: "init",
      jsSource: _TranscoderWorker.jsSource,
      wasmSource: _TranscoderWorker.wasmSource
    });
  }
  static get workerURL() {
    if (!_TranscoderWorker._workerURL) {
      let workerSource = TranscoderWorkerWrapper.TranscoderWorkerWrapper.toString();
      const beginIndex = workerSource.indexOf("{");
      const endIndex = workerSource.lastIndexOf("}");
      workerSource = workerSource.slice(beginIndex + 1, endIndex);
      if (_TranscoderWorker.jsSource) {
        workerSource = `${_TranscoderWorker.jsSource}
${workerSource}`;
      }
      _TranscoderWorker._workerURL = URL.createObjectURL(new Blob([workerSource]));
    }
    return _TranscoderWorker._workerURL;
  }
  initAsync() {
    return this.initPromise;
  }
  async transcodeAsync(basisData, rgbaFormat, rgbFormat) {
    ++this.load;
    const requestID = _TranscoderWorker._tempID++;
    const requestPromise = new Promise((resolve, reject) => {
      this.requests[requestID] = {
        resolve,
        reject
      };
    });
    this.worker.postMessage({
      requestID,
      basisData,
      rgbaFormat,
      rgbFormat,
      type: "transcode"
    });
    return requestPromise;
  }
  static loadTranscoder(jsURL, wasmURL) {
    const jsPromise = fetch(jsURL).then((res) => res.text()).then((text) => {
      _TranscoderWorker.jsSource = text;
    });
    const wasmPromise = fetch(wasmURL).then((res) => res.arrayBuffer()).then((arrayBuffer) => {
      _TranscoderWorker.wasmSource = arrayBuffer;
    });
    return Promise.all([jsPromise, wasmPromise]).then((data) => {
      this._onTranscoderInitializedResolve();
      return data;
    });
  }
  static setTranscoder(jsSource, wasmSource) {
    _TranscoderWorker.jsSource = jsSource;
    _TranscoderWorker.wasmSource = wasmSource;
  }
};
let TranscoderWorker = _TranscoderWorker;
TranscoderWorker.onTranscoderInitialized = new Promise((resolve) => {
  _TranscoderWorker._onTranscoderInitializedResolve = resolve;
});
TranscoderWorker._tempID = 0;

exports.TranscoderWorker = TranscoderWorker;
//# sourceMappingURL=TranscoderWorker.js.map

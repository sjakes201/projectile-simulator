'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function TranscoderWorkerWrapper() {
  let basisBinding;
  const messageHandlers = {
    init: (message) => {
      if (!self.BASIS) {
        console.warn("jsSource was not prepended?");
        return {
          type: "init",
          success: false
        };
      }
      self.BASIS({ wasmBinary: message.wasmSource }).then((basisLibrary) => {
        basisLibrary.initializeBasis();
        basisBinding = basisLibrary;
        self.postMessage({
          type: "init",
          success: true
        });
      });
      return null;
    },
    transcode(message) {
      const basisData = message.basisData;
      const BASIS = basisBinding;
      const data = basisData;
      const basisFile = new BASIS.BasisFile(data);
      const imageCount = basisFile.getNumImages();
      const hasAlpha = basisFile.getHasAlpha();
      const basisFormat = hasAlpha ? message.rgbaFormat : message.rgbFormat;
      const basisFallbackFormat = 14;
      const imageArray = new Array(imageCount);
      let fallbackMode = false;
      if (!basisFile.startTranscoding()) {
        basisFile.close();
        basisFile.delete();
        return {
          type: "transcode",
          requestID: message.requestID,
          success: false,
          imageArray: null
        };
      }
      for (let i = 0; i < imageCount; i++) {
        const levels = basisFile.getNumLevels(i);
        const imageResource = {
          imageID: i,
          levelArray: new Array(),
          width: null,
          height: null
        };
        for (let j = 0; j < levels; j++) {
          const format = !fallbackMode ? basisFormat : basisFallbackFormat;
          const width = basisFile.getImageWidth(i, j);
          const height = basisFile.getImageHeight(i, j);
          const byteSize = basisFile.getImageTranscodedSizeInBytes(i, j, format);
          const alignedWidth = width + 3 & ~3;
          const alignedHeight = height + 3 & ~3;
          if (j === 0) {
            imageResource.width = alignedWidth;
            imageResource.height = alignedHeight;
          }
          const imageBuffer = new Uint8Array(byteSize);
          if (!basisFile.transcodeImage(imageBuffer, i, j, format, false, false)) {
            if (fallbackMode) {
              console.error(`Basis failed to transcode image ${i}, level ${j}!`);
              return { type: "transcode", requestID: message.requestID, success: false };
            }
            console.warn(`Basis failed to transcode image ${i}, level ${j}! Retrying to an uncompressed texture format!`);
            i = -1;
            fallbackMode = true;
            break;
          }
          imageResource.levelArray.push({
            levelID: j,
            levelWidth: width,
            levelHeight: height,
            levelBuffer: imageBuffer
          });
        }
        imageArray[i] = imageResource;
      }
      basisFile.close();
      basisFile.delete();
      return {
        type: "transcode",
        requestID: message.requestID,
        success: true,
        basisFormat: !fallbackMode ? basisFormat : basisFallbackFormat,
        imageArray
      };
    }
  };
  self.onmessage = (e) => {
    const msg = e.data;
    const response = messageHandlers[msg.type](msg);
    if (response) {
      self.postMessage(response);
    }
  };
}

exports.TranscoderWorkerWrapper = TranscoderWorkerWrapper;
//# sourceMappingURL=TranscoderWorkerWrapper.js.map

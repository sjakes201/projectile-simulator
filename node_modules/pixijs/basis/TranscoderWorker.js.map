{"version":3,"file":"TranscoderWorker.js","sources":["../src/TranscoderWorker.ts"],"sourcesContent":["import { TranscoderWorkerWrapper } from './TranscoderWorkerWrapper';\n\nimport type { BASIS_FORMATS } from './Basis';\nimport type { ITranscodeResponse } from './TranscoderWorkerWrapper';\n\n/**\n * Worker class for transcoding *.basis files in background threads.\n *\n * To enable asynchronous transcoding, you need to provide the URL to the basis_universal transcoding\n * library.\n * @memberof PIXI.BasisParser\n */\nexport class TranscoderWorker\n{\n    // IMPLEMENTATION NOTE: TranscoderWorker tracks transcoding requests with a requestID; the worker can be issued\n    // multiple requests (once it is initialized) and the response contains the requestID of the triggering request. Based on\n    // the response, the transcodeAsync promise is fulfilled or rejected.\n\n    // TODO: Publish our own pixijs/basis package & set default URL to jsdelivr/cdnjs\n    /** URL for the script containing the basis_universal library. */\n    static bindingURL: string;\n    static jsSource: string;\n    static wasmSource: ArrayBuffer;\n\n    private static _onTranscoderInitializedResolve: () => void;\n\n    /** a promise that when reslved means the transcoder is ready to be used */\n    public static onTranscoderInitialized = new Promise<void>((resolve) =>\n    {\n        TranscoderWorker._onTranscoderInitializedResolve = resolve;\n    });\n\n    isInit: boolean;\n    load: number;\n    requests: { [id: number]: {\n        resolve: (data: ITranscodeResponse) => void,\n        reject: () => void\n    } } = {};\n\n    private static _workerURL: string;\n    private static _tempID = 0;\n\n    /** Generated URL for the transcoder worker script. */\n    static get workerURL(): string\n    {\n        if (!TranscoderWorker._workerURL)\n        {\n            let workerSource = TranscoderWorkerWrapper.toString();\n\n            const beginIndex = workerSource.indexOf('{');\n            const endIndex = workerSource.lastIndexOf('}');\n\n            workerSource = workerSource.slice(beginIndex + 1, endIndex);\n\n            if (TranscoderWorker.jsSource)\n            {\n                workerSource = `${TranscoderWorker.jsSource}\\n${workerSource}`;\n            }\n\n            TranscoderWorker._workerURL = URL.createObjectURL(new Blob([workerSource]));\n        }\n\n        return TranscoderWorker._workerURL;\n    }\n\n    protected worker: Worker;\n    protected initPromise: Promise<void>;\n    protected onInit: () => void;\n\n    constructor()\n    {\n        this.isInit = false;\n        this.load = 0;\n        this.initPromise = new Promise((resolve) => { this.onInit = resolve; });\n\n        if (!TranscoderWorker.wasmSource)\n        {\n            console.warn('resources.BasisResource.TranscoderWorker has not been given the transcoder WASM binary!');\n        }\n\n        this.worker = new Worker(TranscoderWorker.workerURL);\n        this.worker.onmessage = this.onMessage;\n        this.worker.postMessage({\n            type: 'init',\n            jsSource: TranscoderWorker.jsSource,\n            wasmSource: TranscoderWorker.wasmSource\n        });\n    }\n\n    /** @returns a promise that is resolved when the web-worker is initialized */\n    initAsync(): Promise<void>\n    {\n        return this.initPromise;\n    }\n\n    /**\n     * Creates a promise that will resolve when the transcoding of a *.basis file is complete.\n     * @param basisData - *.basis file contents\n     * @param rgbaFormat - transcoding format for RGBA files\n     * @param rgbFormat - transcoding format for RGB files\n     * @returns a promise that is resolved with the transcoding response of the web-worker\n     */\n    async transcodeAsync(\n        basisData: Uint8Array,\n        rgbaFormat: BASIS_FORMATS,\n        rgbFormat: BASIS_FORMATS\n    ): Promise<ITranscodeResponse>\n    {\n        ++this.load;\n\n        const requestID = TranscoderWorker._tempID++;\n        const requestPromise = new Promise((resolve: (data: ITranscodeResponse) => void, reject: () => void) =>\n        {\n            this.requests[requestID] = {\n                resolve,\n                reject\n            };\n        });\n\n        this.worker.postMessage({\n            requestID,\n            basisData,\n            rgbaFormat,\n            rgbFormat,\n            type: 'transcode'\n        });\n\n        return requestPromise;\n    }\n\n    /**\n     * Handles responses from the web-worker\n     * @param e - a message event containing the transcoded response\n     */\n    protected onMessage = (e: MessageEvent): void =>\n    {\n        const data = e.data as ITranscodeResponse;\n\n        if (data.type === 'init')\n        {\n            if (!data.success)\n            {\n                throw new Error('BasisResource.TranscoderWorker failed to initialize.');\n            }\n\n            this.isInit = true;\n            this.onInit();\n        }\n        else if (data.type === 'transcode')\n        {\n            --this.load;\n\n            const requestID = data.requestID;\n\n            if (data.success)\n            {\n                this.requests[requestID].resolve(data);\n            }\n            else\n            {\n                this.requests[requestID].reject();\n            }\n\n            delete this.requests[requestID];\n        }\n    };\n\n    /**\n     * Loads the transcoder source code\n     * @param jsURL - URL to the javascript basis transcoder\n     * @param wasmURL - URL to the wasm basis transcoder\n     * @returns A promise that resolves when both the js and wasm transcoders have been loaded.\n     */\n    static loadTranscoder(jsURL: string, wasmURL: string): Promise<[void, void]>\n    {\n        const jsPromise = fetch(jsURL)\n            .then((res: Response) => res.text())\n            .then((text: string) => { TranscoderWorker.jsSource = text; });\n        const wasmPromise = fetch(wasmURL)\n            .then((res: Response) => res.arrayBuffer())\n            .then((arrayBuffer: ArrayBuffer) => { TranscoderWorker.wasmSource = arrayBuffer; });\n\n        return Promise.all([jsPromise, wasmPromise]).then((data) =>\n\n        {\n            this._onTranscoderInitializedResolve();\n\n            return data;\n        });\n    }\n\n    /**\n     * Set the transcoder source code directly\n     * @param jsSource - source for the javascript basis transcoder\n     * @param wasmSource - source for the wasm basis transcoder\n     */\n    static setTranscoder(jsSource: string, wasmSource: ArrayBuffer): void\n    {\n        TranscoderWorker.jsSource = jsSource;\n        TranscoderWorker.wasmSource = wasmSource;\n    }\n}\n"],"names":["TranscoderWorkerWrapper"],"mappings":"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"}
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('pixijs/core');

const TEMP_RECT = new core.Rectangle();
class CanvasExtract {
  constructor(renderer) {
    this.renderer = renderer;
  }
  async image(target, format, quality) {
    const image = new Image();
    image.src = await this.base64(target, format, quality);
    return image;
  }
  async base64(target, format, quality) {
    const canvas = this.canvas(target);
    if (canvas.toDataURL !== void 0) {
      return canvas.toDataURL(format, quality);
    }
    if (canvas.convertToBlob !== void 0) {
      const blob = await canvas.convertToBlob({ type: format, quality });
      return await new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.readAsDataURL(blob);
      });
    }
    throw new Error("CanvasExtract.base64() requires ICanvas.toDataURL or ICanvas.convertToBlob to be implemented");
  }
  canvas(target, frame) {
    const renderer = this.renderer;
    let context;
    let resolution;
    let renderTexture;
    if (target) {
      if (target instanceof core.RenderTexture) {
        renderTexture = target;
      } else {
        renderTexture = renderer.generateTexture(target);
      }
    }
    if (renderTexture) {
      context = renderTexture.baseTexture._canvasRenderTarget.context;
      resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;
      frame = frame ?? renderTexture.frame;
    } else {
      context = renderer.canvasContext.rootContext;
      resolution = renderer._view.resolution;
      if (!frame) {
        frame = TEMP_RECT;
        frame.width = renderer.width;
        frame.height = renderer.height;
      }
    }
    const x = Math.round(frame.x * resolution);
    const y = Math.round(frame.y * resolution);
    const width = Math.round(frame.width * resolution);
    const height = Math.round(frame.height * resolution);
    const canvasBuffer = new core.utils.CanvasRenderTarget(width, height, 1);
    const canvasData = context.getImageData(x, y, width, height);
    canvasBuffer.context.putImageData(canvasData, 0, 0);
    return canvasBuffer.canvas;
  }
  pixels(target, frame) {
    const renderer = this.renderer;
    let context;
    let resolution;
    let renderTexture;
    if (target) {
      if (target instanceof core.RenderTexture) {
        renderTexture = target;
      } else {
        renderTexture = renderer.generateTexture(target);
      }
    }
    if (renderTexture) {
      context = renderTexture.baseTexture._canvasRenderTarget.context;
      resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;
      frame = frame ?? renderTexture.frame;
    } else {
      context = renderer.canvasContext.rootContext;
      resolution = renderer.resolution;
      if (!frame) {
        frame = TEMP_RECT;
        frame.width = renderer.width;
        frame.height = renderer.height;
      }
    }
    const x = Math.round(frame.x * resolution);
    const y = Math.round(frame.y * resolution);
    const width = Math.round(frame.width * resolution);
    const height = Math.round(frame.height * resolution);
    return context.getImageData(x, y, width, height).data;
  }
  destroy() {
    this.renderer = null;
  }
}
CanvasExtract.extension = {
  name: "extract",
  type: core.ExtensionType.CanvasRendererSystem
};
core.extensions.add(CanvasExtract);

exports.CanvasExtract = CanvasExtract;
//# sourceMappingURL=CanvasExtract.js.map

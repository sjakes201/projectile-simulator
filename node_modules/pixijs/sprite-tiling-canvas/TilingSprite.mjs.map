{"version":3,"file":"TilingSprite.mjs","sources":["../src/TilingSprite.ts"],"sourcesContent":["import { canvasUtils } from 'pixijs/renderer/canvas';\nimport { Matrix, Point, utils } from 'pixijs/core';\nimport { TilingSprite } from 'pixijs/sprite-tiling';\n\nimport type { CanvasRenderer } from 'pixijs/renderer/canvas';\n\nconst worldMatrix = new Matrix();\nconst patternMatrix = new Matrix();\nconst patternRect = [new Point(), new Point(), new Point(), new Point()];\n\n/**\n * Renders the object using the Canvas renderer\n * @protected\n * @function _renderCanvas\n * @memberof PIXI.TilingSprite#\n * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n */\nTilingSprite.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    const texture = this._texture;\n\n    if (!texture.baseTexture.valid)\n    {\n        return;\n    }\n\n    const context = renderer.canvasContext.activeContext;\n    const transform = this.worldTransform;\n    const baseTexture = texture.baseTexture;\n    const source = baseTexture.getDrawableSource();\n    const baseTextureResolution = baseTexture.resolution;\n\n    // create a nice shiny pattern!\n    if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint)\n    {\n        this._textureID = this._texture._updateID;\n        // cut an object from a spritesheet..\n        const tempCanvas = new utils.CanvasRenderTarget(texture._frame.width,\n            texture._frame.height,\n            baseTextureResolution);\n\n        // Tint the tiling sprite\n        if (this.tint !== 0xFFFFFF)\n        {\n            this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint);\n            tempCanvas.context.drawImage(this._tintedCanvas, 0, 0);\n        }\n        else\n        {\n            tempCanvas.context.drawImage(source,\n                -texture._frame.x * baseTextureResolution, -texture._frame.y * baseTextureResolution);\n        }\n        this._cachedTint = this.tint;\n        this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n    }\n\n    // set context state..\n    context.globalAlpha = this.worldAlpha;\n    renderer.canvasContext.setBlendMode(this.blendMode);\n\n    this.tileTransform.updateLocalTransform();\n    const lt = this.tileTransform.localTransform;\n    const W = this._width;\n    const H = this._height;\n\n    /*\n     * # Implementation Notes\n     *\n     * The tiling transform is not simply a transform on the tiling sprite's local space. If that\n     * were, the bounds of the tiling sprite would change. Rather the tile transform is a transform\n     * on the \"pattern\" coordinates each vertex is assigned.\n     *\n     * To implement the `tileTransform`, we issue drawing commands in the pattern's own space, which\n     * is defined as:\n     *\n     * Pattern_Space = Local_Space x inverse(tileTransform)\n     *\n     * In other words,\n     * Local_Space = Pattern_Space x tileTransform\n     *\n     * We draw the pattern in pattern space, because the space we draw in defines the pattern's coordinates.\n     * In other words, the pattern will always \"originate\" from (0, 0) in the space we draw in.\n     *\n     * This technique is equivalent to drawing a pattern texture, and then finding a quadrilateral that becomes\n     * the tiling sprite's local bounds under the tileTransform and mapping that onto the screen.\n     *\n     * ## uvRespectAnchor\n     *\n     * The preceding paragraph discusses the case without considering `uvRespectAnchor`. The `uvRespectAnchor` flags\n     * where the origin of the pattern space is. Assuming the tileTransform includes no translation, without\n     * loss of generality: If uvRespectAnchor = true, then\n     *\n     * Local Space (0, 0) <--> Pattern Space (0, 0) (where <--> means \"maps to\")\n     *\n     * Here the mapping is provided by trivially by the tileTransform (note tileTransform includes no translation. That\n     * means the invariant under all other transforms are the origins)\n     *\n     * Otherwise,\n     *\n     * Local Space (-localBounds.x, -localBounds.y) <--> Pattern Space (0, 0)\n     *\n     * Here the mapping is provided by the tileTransform PLUS some \"shift\". This shift is done POST-tileTransform. The shift\n     * is equal to the position of the top-left corner of the tiling sprite in its local space.\n     *\n     * Hence,\n     *\n     * Local_Space = Pattern_Space x tileTransform x shiftTransform\n     */\n\n    // worldMatrix is used to convert from pattern space to world space.\n    //\n    // worldMatrix = tileTransform x shiftTransform x worldTransform\n    //             = patternMatrix x worldTransform\n    worldMatrix.identity();\n\n    // patternMatrix is used to convert from pattern space to local space. The drawing commands are issued in pattern space\n    // and this matrix is used to inverse-map the local space vertices into it.\n    //\n    // patternMatrix = tileTransform x shiftTransform\n    patternMatrix.copyFrom(lt);\n\n    // Apply shiftTransform into patternMatrix. See $1.1\n    if (!this.uvRespectAnchor)\n    {\n        patternMatrix.translate(-this.anchor.x * W, -this.anchor.y * H);\n    }\n\n    patternMatrix.scale(1 / baseTextureResolution, 1 / baseTextureResolution);\n    worldMatrix.prepend(patternMatrix);\n    worldMatrix.prepend(transform);\n\n    renderer.canvasContext.setContextTransform(worldMatrix);\n\n    // Fill the pattern!\n    context.fillStyle = this._canvasPattern;\n\n    // The position in local space we are drawing the rectangle: (lx, ly, lx + W, ly + H)\n    const lx = this.anchor.x * -W;\n    const ly = this.anchor.y * -H;\n\n    // Set pattern rect in local space first.\n    patternRect[0].set(lx, ly);\n    patternRect[1].set(lx + W, ly);\n    patternRect[2].set(lx + W, ly + H);\n    patternRect[3].set(lx, ly + H);\n\n    // Map patternRect into pattern space.\n    for (let i = 0; i < 4; i++)\n    {\n        patternMatrix.applyInverse(patternRect[i], patternRect[i]);\n    }\n\n    /*\n     * # Note about verification of theory\n     *\n     * As discussed in the implementation notes, you can verify that `patternRect[0]` will always be (0, 0) in case of\n     * `uvRespectAnchor` false and tileTransform having no translation. Indeed, because the pattern origin should map\n     * to the top-left corner of the tiling sprite in its local space.\n     */\n\n    context.beginPath();\n    context.moveTo(patternRect[0].x, patternRect[0].y);\n\n    for (let i = 1; i < 4; i++)\n    {\n        context.lineTo(patternRect[i].x, patternRect[i].y);\n    }\n\n    context.closePath();\n    context.fill();\n};\n"],"names":[],"mappings":";;;;AAMA,MAAM,WAAA,GAAc,IAAI,MAAO,EAAA,CAAA;AAC/B,MAAM,aAAA,GAAgB,IAAI,MAAO,EAAA,CAAA;AACjC,MAAM,WAAc,GAAA,CAAC,IAAI,KAAA,EAAS,EAAA,IAAI,KAAM,EAAA,EAAG,IAAI,KAAA,EAAS,EAAA,IAAI,OAAO,CAAA,CAAA;AASvE,YAAa,CAAA,SAAA,CAAU,aAAgB,GAAA,SAAA,aAAA,CAAuB,QAC9D,EAAA;AACI,EAAA,MAAM,UAAU,IAAK,CAAA,QAAA,CAAA;AAErB,EAAI,IAAA,CAAC,OAAQ,CAAA,WAAA,CAAY,KACzB,EAAA;AACI,IAAA,OAAA;AAAA,GACJ;AAEA,EAAM,MAAA,OAAA,GAAU,SAAS,aAAc,CAAA,aAAA,CAAA;AACvC,EAAA,MAAM,YAAY,IAAK,CAAA,cAAA,CAAA;AACvB,EAAA,MAAM,cAAc,OAAQ,CAAA,WAAA,CAAA;AAC5B,EAAM,MAAA,MAAA,GAAS,YAAY,iBAAkB,EAAA,CAAA;AAC7C,EAAA,MAAM,wBAAwB,WAAY,CAAA,UAAA,CAAA;AAG1C,EAAI,IAAA,IAAA,CAAK,eAAe,IAAK,CAAA,QAAA,CAAS,aAAa,IAAK,CAAA,WAAA,KAAgB,KAAK,IAC7E,EAAA;AACI,IAAK,IAAA,CAAA,UAAA,GAAa,KAAK,QAAS,CAAA,SAAA,CAAA;AAEhC,IAAM,MAAA,UAAA,GAAa,IAAI,KAAA,CAAM,kBAAmB,CAAA,OAAA,CAAQ,OAAO,KAC3D,EAAA,OAAA,CAAQ,MAAO,CAAA,MAAA,EACf,qBAAqB,CAAA,CAAA;AAGzB,IAAI,IAAA,IAAA,CAAK,SAAS,QAClB,EAAA;AACI,MAAA,IAAA,CAAK,aAAgB,GAAA,WAAA,CAAY,eAAgB,CAAA,IAAA,EAAM,KAAK,IAAI,CAAA,CAAA;AAChE,MAAA,UAAA,CAAW,OAAQ,CAAA,SAAA,CAAU,IAAK,CAAA,aAAA,EAAe,GAAG,CAAC,CAAA,CAAA;AAAA,KAGzD,MAAA;AACI,MAAA,UAAA,CAAW,OAAQ,CAAA,SAAA,CAAU,MACzB,EAAA,CAAC,OAAQ,CAAA,MAAA,CAAO,CAAI,GAAA,qBAAA,EAAuB,CAAC,OAAA,CAAQ,MAAO,CAAA,CAAA,GAAI,qBAAqB,CAAA,CAAA;AAAA,KAC5F;AACA,IAAA,IAAA,CAAK,cAAc,IAAK,CAAA,IAAA,CAAA;AACxB,IAAA,IAAA,CAAK,iBAAiB,UAAW,CAAA,OAAA,CAAQ,aAAc,CAAA,UAAA,CAAW,QAAQ,QAAQ,CAAA,CAAA;AAAA,GACtF;AAGA,EAAA,OAAA,CAAQ,cAAc,IAAK,CAAA,UAAA,CAAA;AAC3B,EAAS,QAAA,CAAA,aAAA,CAAc,YAAa,CAAA,IAAA,CAAK,SAAS,CAAA,CAAA;AAElD,EAAA,IAAA,CAAK,cAAc,oBAAqB,EAAA,CAAA;AACxC,EAAM,MAAA,EAAA,GAAK,KAAK,aAAc,CAAA,cAAA,CAAA;AAC9B,EAAA,MAAM,IAAI,IAAK,CAAA,MAAA,CAAA;AACf,EAAA,MAAM,IAAI,IAAK,CAAA,OAAA,CAAA;AAkDf,EAAA,WAAA,CAAY,QAAS,EAAA,CAAA;AAMrB,EAAA,aAAA,CAAc,SAAS,EAAE,CAAA,CAAA;AAGzB,EAAI,IAAA,CAAC,KAAK,eACV,EAAA;AACI,IAAc,aAAA,CAAA,SAAA,CAAU,CAAC,IAAA,CAAK,MAAO,CAAA,CAAA,GAAI,GAAG,CAAC,IAAA,CAAK,MAAO,CAAA,CAAA,GAAI,CAAC,CAAA,CAAA;AAAA,GAClE;AAEA,EAAA,aAAA,CAAc,KAAM,CAAA,CAAA,GAAI,qBAAuB,EAAA,CAAA,GAAI,qBAAqB,CAAA,CAAA;AACxE,EAAA,WAAA,CAAY,QAAQ,aAAa,CAAA,CAAA;AACjC,EAAA,WAAA,CAAY,QAAQ,SAAS,CAAA,CAAA;AAE7B,EAAS,QAAA,CAAA,aAAA,CAAc,oBAAoB,WAAW,CAAA,CAAA;AAGtD,EAAA,OAAA,CAAQ,YAAY,IAAK,CAAA,cAAA,CAAA;AAGzB,EAAA,MAAM,EAAK,GAAA,IAAA,CAAK,MAAO,CAAA,CAAA,GAAI,CAAC,CAAA,CAAA;AAC5B,EAAA,MAAM,EAAK,GAAA,IAAA,CAAK,MAAO,CAAA,CAAA,GAAI,CAAC,CAAA,CAAA;AAG5B,EAAY,WAAA,CAAA,CAAA,CAAA,CAAG,GAAI,CAAA,EAAA,EAAI,EAAE,CAAA,CAAA;AACzB,EAAA,WAAA,CAAY,CAAG,CAAA,CAAA,GAAA,CAAI,EAAK,GAAA,CAAA,EAAG,EAAE,CAAA,CAAA;AAC7B,EAAA,WAAA,CAAY,CAAG,CAAA,CAAA,GAAA,CAAI,EAAK,GAAA,CAAA,EAAG,KAAK,CAAC,CAAA,CAAA;AACjC,EAAA,WAAA,CAAY,CAAG,CAAA,CAAA,GAAA,CAAI,EAAI,EAAA,EAAA,GAAK,CAAC,CAAA,CAAA;AAG7B,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,CAAA,EAAG,CACvB,EAAA,EAAA;AACI,IAAA,aAAA,CAAc,YAAa,CAAA,WAAA,CAAY,CAAI,CAAA,EAAA,WAAA,CAAY,CAAE,CAAA,CAAA,CAAA;AAAA,GAC7D;AAUA,EAAA,OAAA,CAAQ,SAAU,EAAA,CAAA;AAClB,EAAA,OAAA,CAAQ,OAAO,WAAY,CAAA,CAAA,CAAA,CAAG,CAAG,EAAA,WAAA,CAAY,GAAG,CAAC,CAAA,CAAA;AAEjD,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,CAAA,EAAG,CACvB,EAAA,EAAA;AACI,IAAA,OAAA,CAAQ,OAAO,WAAY,CAAA,CAAA,CAAA,CAAG,CAAG,EAAA,WAAA,CAAY,GAAG,CAAC,CAAA,CAAA;AAAA,GACrD;AAEA,EAAA,OAAA,CAAQ,SAAU,EAAA,CAAA;AAClB,EAAA,OAAA,CAAQ,IAAK,EAAA,CAAA;AACjB,CAAA"}
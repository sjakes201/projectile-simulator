import { canvasUtils } from 'pixijs/renderer/canvas';
import { Matrix, Point, utils } from 'pixijs/core';
import { TilingSprite } from 'pixijs/sprite-tiling';

const worldMatrix = new Matrix();
const patternMatrix = new Matrix();
const patternRect = [new Point(), new Point(), new Point(), new Point()];
TilingSprite.prototype._renderCanvas = function _renderCanvas(renderer) {
  const texture = this._texture;
  if (!texture.baseTexture.valid) {
    return;
  }
  const context = renderer.canvasContext.activeContext;
  const transform = this.worldTransform;
  const baseTexture = texture.baseTexture;
  const source = baseTexture.getDrawableSource();
  const baseTextureResolution = baseTexture.resolution;
  if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint) {
    this._textureID = this._texture._updateID;
    const tempCanvas = new utils.CanvasRenderTarget(texture._frame.width, texture._frame.height, baseTextureResolution);
    if (this.tint !== 16777215) {
      this._tintedCanvas = canvasUtils.getTintedCanvas(this, this.tint);
      tempCanvas.context.drawImage(this._tintedCanvas, 0, 0);
    } else {
      tempCanvas.context.drawImage(source, -texture._frame.x * baseTextureResolution, -texture._frame.y * baseTextureResolution);
    }
    this._cachedTint = this.tint;
    this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, "repeat");
  }
  context.globalAlpha = this.worldAlpha;
  renderer.canvasContext.setBlendMode(this.blendMode);
  this.tileTransform.updateLocalTransform();
  const lt = this.tileTransform.localTransform;
  const W = this._width;
  const H = this._height;
  worldMatrix.identity();
  patternMatrix.copyFrom(lt);
  if (!this.uvRespectAnchor) {
    patternMatrix.translate(-this.anchor.x * W, -this.anchor.y * H);
  }
  patternMatrix.scale(1 / baseTextureResolution, 1 / baseTextureResolution);
  worldMatrix.prepend(patternMatrix);
  worldMatrix.prepend(transform);
  renderer.canvasContext.setContextTransform(worldMatrix);
  context.fillStyle = this._canvasPattern;
  const lx = this.anchor.x * -W;
  const ly = this.anchor.y * -H;
  patternRect[0].set(lx, ly);
  patternRect[1].set(lx + W, ly);
  patternRect[2].set(lx + W, ly + H);
  patternRect[3].set(lx, ly + H);
  for (let i = 0; i < 4; i++) {
    patternMatrix.applyInverse(patternRect[i], patternRect[i]);
  }
  context.beginPath();
  context.moveTo(patternRect[0].x, patternRect[0].y);
  for (let i = 1; i < 4; i++) {
    context.lineTo(patternRect[i].x, patternRect[i].y);
  }
  context.closePath();
  context.fill();
};
//# sourceMappingURL=TilingSprite.mjs.map

<!doctype html>
<html>

<head>
    <title>Projectile Motion</title>
    <link rel="stylesheet" href="styles.css" type="text/css" />
    <script src="https://pixijs.download/release/pixi.min.js">
    </script>

</head>

<body>
    <div class="simulation">
        <script type="module">
            // Step 1: [Initialize framework: create the application helper and add its render target to the page]
            const app = new PIXI.Application();
            await app.init({ width: 0.8 * window.innerWidth, height: window.innerHeight, background: '#1099bb' })
            document.querySelector('.simulation').appendChild(app.canvas);

            let vw = 0.80 * (window.innerWidth / 100);
            let vh = window.innerHeight / 100;

            // Step 2: [Define helper functions and physics constants]
            const airDensity = 1.225; // kg/m^3
            const dragCoefficient = 0.47; // for a sphere
            const radius = 0.1; // meters (adjust as necessary)
            const crossSectionalArea = Math.PI * radius * radius; // m^2


            const calc_horizontal_pos = (x0, v0, t) => x0 + v0 * t
            const calc_vertical_pos = (y0, v0, t, g) => y0 + v0 * t + 0.5 * g * (t * t);

            const calc_position_with_air_resistance = (x0, y0, vx0, vy0, t, mass) => {
                const dragForceX = 0.5 * airDensity * vx0 * vx0 * dragCoefficient * crossSectionalArea;
                const dragForceY = 0.5 * airDensity * vy0 * vy0 * dragCoefficient * crossSectionalArea;

                const accelX = -dragForceX / mass;
                const accelY = -dragForceY / mass;

                const newX = x0 + vx0 * t + 0.5 * accelX * t * t;
                const newY = y0 + vy0 * t + 0.5 * (inputs.gravityConstant + accelY) * t * t;

                return { x: newX, y: newY };
            };

            const calc_position_without_air_resistance = (x0, y0, vx0, vy0, t, g) => {
                const newX = x0 + vx0 * t;
                const newY = y0 + vy0 * t + 0.5 * g * t * t;

                return { x: newX, y: newY };
            };

            const calc_horizontal_velocity = (v0, t, mass, withAirResistance) => {
                if (withAirResistance) {
                    const dragForce = 0.5 * airDensity * v0 * v0 * dragCoefficient * crossSectionalArea;
                    const acceleration = -dragForce / mass;
                    return v0 + acceleration * t;
                } else {
                    return v0;
                }
            }

            const calc_vertical_velocity = (v0, t, g, mass, withAirResistance) => {
                if (withAirResistance) {
                    const dragForce = 0.5 * airDensity * v0 * v0 * dragCoefficient * crossSectionalArea;
                    const acceleration = -dragForce / mass;
                    return v0 + (g + acceleration) * t;
                } else {
                    return v0 + g * t;
                }
            }

            // Step 3: [Define state, inputs, and stats-recording objects]
            const state = {
                // state is for the frequently updating information about the projectile
                moving: false,
                potentialEnergy: 0,
                kineticEnergy: 0,
                xVelocity: 0,
                yVelocity: 0,
                speed: 0,
                flightTime: 0,
                pathDots: []
            }

            const inputs = {
                // inputs are for user inputs used in the physics calculations
                initYVelocity: 0,
                initXVelocity: 0,
                angle: 45,
                gravityConstant: -9.81,
                mass: 10,
                initialHeight: 0,
            }

            const stats = {
                // stats are to hold records for max / highest etc along trajectory
                maxHeight: 0,
                maxSpeed: 0
            }

            // Step 4: [Init sprites and input boxes]

            // Init cannon
            await PIXI.Assets.load('assets/images/cannon.png');
            let cannon = PIXI.Sprite.from('assets/images/cannon.png');
            cannon.anchor.set(0.5)
            cannon.width = 8 * vw
            cannon.height = 8 * vw
            cannon.x = vw * 5;
            cannon.y = vh * (100 - 4.8 - inputs.initialHeight);
            app.stage.addChild(cannon);

            // Init cannonball
            await PIXI.Assets.load('assets/images/cannonball.webp');
            let projectile = PIXI.Sprite.from('assets/images/cannonball.webp');
            projectile.anchor.set(0.5)
            projectile.width = 5 * vw
            projectile.height = 5 * vw
            projectile.x = vw * 5;
            projectile.y = vh * (100 - 8.5 - inputs.initialHeight);
            projectile.alpha = 0;
            app.stage.addChild(projectile);

            // Init ground
            let ground = new PIXI.Graphics()
                .rect(0, vh * 98, 100 * vw, 2 * vh)
                .fill(0x000000)
            app.stage.addChild(ground)


            // Step 5: [Define runtime functions]
            const setDocElementContents = (id, value) => {
                document.getElementById(id).innerText = value;
            }

            const clearPathDots = () => {
                state.pathDots.forEach(dot => app.stage.removeChild(dot));
                state.pathDots = [];
            }

            const resetSimulation = () => {
                state.moving = false;
                projectile.x = vw * 5;
                projectile.y = vh * (100 - 8.5 - inputs.initialHeight);
                projectile.alpha = 0;
                stats.maxHeight = 0;
                stats.maxSpeed = 0;
                setDocElementContents('max-height', 0 + ' m');
                setDocElementContents('max-speed', 0 + ' m/s');
            }

            const setInputs = (velocity, angle, mass, height, gravity) => {
                resetSimulation()
                clearPathDots()
                height = height + 1 // minimum height 1
                inputs.angle = angle
                inputs.initYVelocity = velocity * Math.sin(angle * Math.PI / 180);
                inputs.initXVelocity = velocity * Math.cos(angle * Math.PI / 180);
                inputs.initialHeight = height;
                inputs.mass = mass;
                inputs.gravityConstant = gravity;
                cannon.rotation = -angle * Math.PI / 180;
                cannon.y = vh * (100 - 4.8 - height); //update cannon height 
            }

            // Save reference to ticker function to cancel and reset when shoot is called again
            let tickerFunction;
            const shoot = () => {
                resetSimulation()
                if (tickerFunction) {
                    app.ticker.remove(tickerFunction);
                }
                clearPathDots();

                const withAirResistance = document.getElementById('air-resistance').checked;

                projectile.alpha = 1;
                state.moving = true;
                const ticksPerFrame = 25; // How frequently to update frames
                let elapsed = 0.0;

                tickerFunction = (ticker) => {
                    if (state.moving) {
                        state.flightTime = elapsed;
                        elapsed += ticker.deltaTime / ticksPerFrame;
                        setDocElementContents('flight-time', elapsed.toFixed(2) + ' s');

                        // Calculate new coordinates with or without air resistance
                        let newX, newY = 0;
                        if (withAirResistance) {
                            let newCoords = calc_position_with_air_resistance(5, inputs.initialHeight + 8, inputs.initXVelocity, inputs.initYVelocity, elapsed, inputs.mass);
                            newX = vw * Math.round(newCoords.x);
                            newY = vh * Math.round(100 - newCoords.y);
                        } else {
                            newX = vw * calc_horizontal_pos(5, inputs.initXVelocity, elapsed);
                            newY = vh * (100 - Math.round(calc_vertical_pos(inputs.initialHeight + 8, inputs.initYVelocity, elapsed, inputs.gravityConstant)))
                        }

                        let height = (vh * 100) - newY;

                        if (height > stats.maxHeight) {
                            stats.maxHeight = height;
                            setDocElementContents('max-height', height.toFixed(2) + ' m');
                        }
                        // Put tracking dot for projectile path
                        let dot = new PIXI.Graphics();
                        dot.beginFill(0xFF0000); // Red color
                        dot.drawCircle(0, 0, 2); // Radius of 2
                        dot.endFill();
                        dot.x = newX;
                        dot.y = newY;
                        app.stage.addChild(dot);
                        state.pathDots.push(dot);

                        // Check for out of screen and stopping conditions
                        if (newX <= vw * 97.5 && newX >= vw * 2.5) {
                            projectile.x = newX;
                        } else {
                            projectile.alpha = 0.5;
                        }

                        if (height > stats.maxHeight) {
                            stats.maxHeight = height;
                        }

                        if (newY < vh * 97.5 && newY >= vh * 0.5) {
                            projectile.y = newY;
                        } else {
                            projectile.alpha = 0.5;
                        }

                        if (newY >= vh * 97.5) {
                            state.moving = false;
                        }

                        const xVelocity = calc_horizontal_velocity(inputs.initXVelocity, elapsed, inputs.mass, withAirResistance);
                        const yVelocity = calc_vertical_velocity(inputs.initYVelocity, elapsed, inputs.gravityConstant, inputs.mass, withAirResistance);
                        setDocElementContents('x-velocity', xVelocity.toFixed(2) + ' m/s');
                        setDocElementContents('y-velocity', yVelocity.toFixed(2) + ' m/s');

                        const speed = Math.sqrt(xVelocity * xVelocity + yVelocity * yVelocity);
                        setDocElementContents('magnitude-velocity', speed.toFixed(2) + ' m/s');

                        if (speed > stats.maxSpeed) {
                            stats.maxSpeed = speed;
                            setDocElementContents('max-speed', speed.toFixed(2) + ' m/s');
                        }

                        let PE = Math.round(inputs.mass * Math.abs(inputs.gravityConstant) * (height / vh));
                        let KE = Math.round(0.5 * inputs.mass * speed * speed);

                        state.xVelocity = xVelocity;
                        state.yVelocity = yVelocity;
                        state.speed = speed;

                        if (speed > stats.maxSpeed) {
                            stats.maxSpeed = speed;
                        }
                    } else {
                        app.ticker.remove(tickerFunction);
                        state.xVelocity = 0;
                        state.yVelocity = 0;
                        state.speed = 0;
                        setDocElementContents('x-velocity', 0 + ' m/s');
                        setDocElementContents('y-velocity', 0 + ' m/s');
                        setDocElementContents('magnitude-velocity', 0 + ' m/s');

                    }
                };

                app.ticker.add(tickerFunction);
            };


            // Step 6: [Event Listeners and defaults]

            setInputs(30, 45, 1, 0, -9.81);

            document.getElementById('setInputsBtn').addEventListener('click', () => {
                const velocity = parseFloat(document.getElementById('speed').value);
                const angle = parseFloat(document.getElementById('angle').value);
                const mass = parseFloat(document.getElementById('mass').value);
                const height = parseFloat(document.getElementById('height').value);
                const gravity = parseFloat(document.getElementById('gravity').value);
                setInputs(velocity, angle, mass, height, gravity);
            })

            document.getElementById('shootButton').addEventListener('click', () => {
                shoot();
            })


        </script>
    </div>

    <div class="text-area">

        <div class="input-group">
            <label for="height">Initial Height:</label>
            <input type="number" min="0" max="90" id="height" name="height" value="0.00">
        </div>
        <div class="input-group">
            <label for="speed"> Initial speed:</label>
            <input type="number" min="0" id="speed" name="speed" value="30.00">
        </div>
        <div class="input-group">
            <label for="angle">Angle:</label>
            <input type="number" min="-359" max="359" id="angle" name="angle" value="45">
        </div>
        <div class="input-group">
            <label for="mass">Mass:</label>
            <input type="number" min="0" id="mass" name="mass" value="1.00">
        </div>
        <div class="input-group">
            <label for="gravity">Gravitational Acceleration:</label>
            <input type="number" id="gravity" name="gravity" value="-9.810">
        </div>

        <div class="input-group">
            <label for="air-resistance">Enable Air Resistance:
                <input type="checkbox" id="air-resistance" name="air-resistance">
            </label>
        </div>


        <button id="setInputsBtn">Set Inputs</button>
        <button id="shootButton">Shoot</button>



        <div class="input-group">
            <div class="stats-box">
                <label for="y-velocity">Y Velocity
                    <span id="y-velocity">0.00 m/s</span>
                </label>
                <label for="x-velocity">X Velocity
                    <span id="x-velocity">0.00 m/s</span>
                </label>
                <label for="magnitude-velocity">Speed
                    <span id="magnitude-velocity">0.00 m/s</span>
                </label>
                <label for="flight-time">Flight Time
                    <span id="flight-time">0.00 s</span>
                </label>
            </div>
        </div>

        <div class="input-group">
            <div class="stats-box">
                <label for="max-height">Max Height
                    <span id="max-height">0.00 m</span>
                </label>
                <label for="max-speed">Max Speed
                    <span id="max-speed">0.00 m/s</span>
                </label>
            </div>
        </div>


    </div>

</body>

</html>